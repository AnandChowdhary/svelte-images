/*
Copyright (c) 2020 Sibtain Jafferi
name: svelte-images
license: MIT
author: sjafferi
repository: git+https://github.com/sjafferi/svelte-images.git
version: 0.0.1
*/
'use strict';

var internal = require('svelte/internal');
var svelte = require('svelte');
var transition = require('svelte/transition');

/* src/Images/Carousel.svelte generated by Svelte v3.18.1 */

function add_css() {
  var style = internal.element("style");
  style.id = "svelte-1m10vl8-style";
  style.textContent = ".carousel.svelte-1m10vl8.svelte-1m10vl8{position:relative;overflow:hidden;display:inline-flex;transition:transform 500ms cubic-bezier(0.23, 1, 0.32, 1) 0s,\n      opacity 500ms cubic-bezier(0.23, 1, 0.32, 1) 0s}.nav.svelte-1m10vl8.svelte-1m10vl8{display:flex;box-sizing:border-box;-webkit-box-align:center;align-items:center;-webkit-box-pack:justify;justify-content:space-between;position:absolute;width:100vw;height:100%}.carousel.svelte-1m10vl8 img.svelte-1m10vl8{height:100%;width:auto;margin:auto;user-select:none}.carousel.svelte-1m10vl8 .img-container.svelte-1m10vl8{width:100vw;display:flex;justify-content:center}.nav.svelte-1m10vl8 button.svelte-1m10vl8{cursor:pointer;background:transparent;border:none;outline:none !important;background:rgba(255, 255, 255, 0.2);border-radius:50%;width:50px;height:50px;display:flex;color:white;margin:0 20px}.nav.svelte-1m10vl8 svg.svelte-1m10vl8{display:inline-block;fill:currentcolor;height:48px;stroke:currentcolor;stroke-width:0;width:48px}.empty.svelte-1m10vl8.svelte-1m10vl8{width:100px}";
  internal.append(document.head, style);
}

function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  child_ctx[10] = i;
  return child_ctx;
} // (104:8) {:else}


function create_else_block_1(ctx) {
  let div;
  return {
    c() {
      div = internal.element("div");
      internal.attr(div, "class", "empty svelte-1m10vl8");
    },

    m(target, anchor) {
      internal.insert(target, div, anchor);
    },

    p: internal.noop,
    i: internal.noop,
    o: internal.noop,

    d(detaching) {
      if (detaching) internal.detach(div);
    }

  };
} // (97:8) {#if blink && curr_idx > 0}


function create_if_block_1(ctx) {
  let button;
  let button_intro;
  let button_outro;
  let current;
  let dispose;
  return {
    c() {
      button = internal.element("button");
      button.innerHTML = `<svg role="presentation" viewBox="0 0 24 24" class="css-8wgz7g svelte-1m10vl8"><path d="M15.422 16.078l-1.406 1.406-6-6 6-6 1.406 1.406-4.594 4.594z"></path></svg>`;
      internal.attr(button, "class", "svelte-1m10vl8");
    },

    m(target, anchor) {
      internal.insert(target, button, anchor);
      current = true;
      dispose = internal.listen(button, "click",
      /*left*/
      ctx[5]);
    },

    p: internal.noop,

    i(local) {
      if (current) return;
      internal.add_render_callback(() => {
        if (button_outro) button_outro.end(1);
        if (!button_intro) button_intro = internal.create_in_transition(button, transition.fade, {});
        button_intro.start();
      });
      current = true;
    },

    o(local) {
      if (button_intro) button_intro.invalidate();
      button_outro = internal.create_out_transition(button, transition.fade, {});
      current = false;
    },

    d(detaching) {
      if (detaching) internal.detach(button);
      if (detaching && button_outro) button_outro.end();
      dispose();
    }

  };
} // (113:8) {:else}


function create_else_block(ctx) {
  let div;
  return {
    c() {
      div = internal.element("div");
      internal.attr(div, "class", "empty svelte-1m10vl8");
    },

    m(target, anchor) {
      internal.insert(target, div, anchor);
    },

    p: internal.noop,
    i: internal.noop,
    o: internal.noop,

    d(detaching) {
      if (detaching) internal.detach(div);
    }

  };
} // (107:8) {#if blink && curr_idx < images.length - 1}


function create_if_block(ctx) {
  let button;
  let button_intro;
  let button_outro;
  let current;
  let dispose;
  return {
    c() {
      button = internal.element("button");
      button.innerHTML = `<svg role="presentation" viewBox="0 0 24 24" class="css-8wgz7g svelte-1m10vl8"><path d="M9.984 6l6 6-6 6-1.406-1.406 4.594-4.594-4.594-4.594z"></path></svg>`;
      internal.attr(button, "class", "svelte-1m10vl8");
    },

    m(target, anchor) {
      internal.insert(target, button, anchor);
      current = true;
      dispose = internal.listen(button, "click",
      /*right*/
      ctx[4]);
    },

    p: internal.noop,

    i(local) {
      if (current) return;
      internal.add_render_callback(() => {
        if (button_outro) button_outro.end(1);
        if (!button_intro) button_intro = internal.create_in_transition(button, transition.fade, {});
        button_intro.start();
      });
      current = true;
    },

    o(local) {
      if (button_intro) button_intro.invalidate();
      button_outro = internal.create_out_transition(button, transition.fade, {});
      current = false;
    },

    d(detaching) {
      if (detaching) internal.detach(button);
      if (detaching && button_outro) button_outro.end();
      dispose();
    }

  };
} // (94:2) {#each images as image, i}


function create_each_block(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t0;
  let current_block_type_index_1;
  let if_block1;
  let t1;
  let img;
  let t2;
  let current;
  const if_block_creators = [create_if_block_1, create_else_block_1];
  const if_blocks = [];

  function select_block_type(ctx, dirty) {
    if (
    /*blink*/
    ctx[3] &&
    /*curr_idx*/
    ctx[0] > 0) return 0;
    return 1;
  }

  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const if_block_creators_1 = [create_if_block, create_else_block];
  const if_blocks_1 = [];

  function select_block_type_1(ctx, dirty) {
    if (
    /*blink*/
    ctx[3] &&
    /*curr_idx*/
    ctx[0] <
    /*images*/
    ctx[1].length - 1) return 0;
    return 1;
  }

  current_block_type_index_1 = select_block_type_1(ctx);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  let img_levels = [
  /*image*/
  ctx[8], {
    alt:
    /*image*/
    ctx[8].alt || ""
  }];
  let img_data = {};

  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = internal.assign(img_data, img_levels[i]);
  }

  return {
    c() {
      div1 = internal.element("div");
      div0 = internal.element("div");
      if_block0.c();
      t0 = internal.space();
      if_block1.c();
      t1 = internal.space();
      img = internal.element("img");
      t2 = internal.space();
      internal.attr(div0, "class", "nav svelte-1m10vl8");
      internal.set_attributes(img, img_data);
      internal.toggle_class(img, "svelte-1m10vl8", true);
      internal.attr(div1, "class", "img-container svelte-1m10vl8");
    },

    m(target, anchor) {
      internal.insert(target, div1, anchor);
      internal.append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      internal.append(div0, t0);
      if_blocks_1[current_block_type_index_1].m(div0, null);
      internal.append(div1, t1);
      internal.append(div1, img);
      internal.append(div1, t2);
      current = true;
    },

    p(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);

      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        internal.group_outros();
        internal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        internal.check_outros();
        if_block0 = if_blocks[current_block_type_index];

        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block0.c();
        }

        internal.transition_in(if_block0, 1);
        if_block0.m(div0, t0);
      }

      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx);

      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx, dirty);
      } else {
        internal.group_outros();
        internal.transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        internal.check_outros();
        if_block1 = if_blocks_1[current_block_type_index_1];

        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
          if_block1.c();
        }

        internal.transition_in(if_block1, 1);
        if_block1.m(div0, null);
      }

      internal.set_attributes(img, internal.get_spread_update(img_levels, [dirty &
      /*images*/
      2 &&
      /*image*/
      ctx[8], dirty &
      /*images*/
      2 && {
        alt:
        /*image*/
        ctx[8].alt || ""
      }]));
      internal.toggle_class(img, "svelte-1m10vl8", true);
    },

    i(local) {
      if (current) return;
      internal.transition_in(if_block0);
      internal.transition_in(if_block1);
      current = true;
    },

    o(local) {
      internal.transition_out(if_block0);
      internal.transition_out(if_block1);
      current = false;
    },

    d(detaching) {
      if (detaching) internal.detach(div1);
      if_blocks[current_block_type_index].d();
      if_blocks_1[current_block_type_index_1].d();
    }

  };
}

function create_fragment(ctx) {
  let div;
  let div_style_value;
  let current;
  let each_value =
  /*images*/
  ctx[1];
  let each_blocks = [];

  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }

  const out = i => internal.transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });

  return {
    c() {
      div = internal.element("div");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      internal.attr(div, "class", "carousel svelte-1m10vl8");
      internal.attr(div, "style", div_style_value = `transform: translate3d(${
      /*translateX*/
      ctx[2]}px, 0, 0);`);
    },

    m(target, anchor) {
      internal.insert(target, div, anchor);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }

      current = true;
    },

    p(ctx, [dirty]) {
      if (dirty &
      /*images, right, blink, curr_idx, left*/
      59) {
        each_value =
        /*images*/
        ctx[1];
        let i;

        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);

          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            internal.transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            internal.transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }

        internal.group_outros();

        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }

        internal.check_outros();
      }

      if (!current || dirty &
      /*translateX*/
      4 && div_style_value !== (div_style_value = `transform: translate3d(${
      /*translateX*/
      ctx[2]}px, 0, 0);`)) {
        internal.attr(div, "style", div_style_value);
      }
    },

    i(local) {
      if (current) return;

      for (let i = 0; i < each_value.length; i += 1) {
        internal.transition_in(each_blocks[i]);
      }

      current = true;
    },

    o(local) {
      each_blocks = each_blocks.filter(Boolean);

      for (let i = 0; i < each_blocks.length; i += 1) {
        internal.transition_out(each_blocks[i]);
      }

      current = false;
    },

    d(detaching) {
      if (detaching) internal.detach(div);
      internal.destroy_each(each_blocks, detaching);
    }

  };
}

const blinkDelay = 50;

function decrement(num) {
  return num == 0 ? 0 : num - 1;
}

function instance($$self, $$props, $$invalidate) {
  let {
    images
  } = $$props;
  let {
    curr_idx = 0
  } = $$props;
  let translateX = -curr_idx * window.innerWidth;

  function increment(num) {
    return num >= images.length - 1 ? num : num + 1;
  }

  let blink = true;

  function doBlink() {
    $$invalidate(3, blink = false);
    setTimeout(() => $$invalidate(3, blink = true), blinkDelay);
  }

  function right() {
    doBlink();
    $$invalidate(0, curr_idx = increment(curr_idx));
    $$invalidate(2, translateX -= window.innerWidth);
  }

  function left() {
    doBlink();
    $$invalidate(0, curr_idx = decrement(curr_idx));
    $$invalidate(2, translateX += window.innerWidth);
  }

  $$self.$set = $$props => {
    if ("images" in $$props) $$invalidate(1, images = $$props.images);
    if ("curr_idx" in $$props) $$invalidate(0, curr_idx = $$props.curr_idx);
  };

  return [curr_idx, images, translateX, blink, right, left];
}

class Carousel extends internal.SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-1m10vl8-style")) add_css();
    internal.init(this, options, instance, create_fragment, internal.safe_not_equal, {
      images: 1,
      curr_idx: 0
    });
  }

}

/* src/Images/Images.svelte generated by Svelte v3.18.1 */

function add_css$1() {
  var style = internal.element("style");
  style.id = "svelte-lk00e3-style";
  style.textContent = ".gallery.svelte-lk00e3.svelte-lk00e3{display:flex;flex-wrap:wrap;flex:1 1}.img-container.svelte-lk00e3.svelte-lk00e3{background-color:#eee;box-sizing:border-box;float:left;margin:calc(var(--gutter) * 1px);overflow:hidden;position:relative;width:calc(25% - var(--gutter) * 2px)}.img-container.svelte-lk00e3.svelte-lk00e3:hover{opacity:0.9}.img-container.svelte-lk00e3 img.svelte-lk00e3{cursor:pointer;position:absolute;max-width:100%}";
  internal.append(document.head, style);
}

function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  child_ctx[7] = i;
  return child_ctx;
} // (44:2) {#each images as image, i}


function create_each_block$1(ctx) {
  let div;
  let img;
  let t;
  let dispose;
  let img_levels = [
  /*image*/
  ctx[5], {
    alt:
    /*image*/
    ctx[5].alt || ""
  }];
  let img_data = {};

  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = internal.assign(img_data, img_levels[i]);
  }

  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[4](
      /*i*/
      ctx[7], ...args)
    );
  }

  return {
    c() {
      div = internal.element("div");
      img = internal.element("img");
      t = internal.space();
      internal.set_attributes(img, img_data);
      internal.toggle_class(img, "svelte-lk00e3", true);
      internal.attr(div, "class", "img-container svelte-lk00e3");
    },

    m(target, anchor) {
      internal.insert(target, div, anchor);
      internal.append(div, img);
      internal.append(div, t);
      dispose = internal.listen(img, "click", click_handler);
    },

    p(new_ctx, dirty) {
      ctx = new_ctx;
      internal.set_attributes(img, internal.get_spread_update(img_levels, [dirty &
      /*images*/
      1 &&
      /*image*/
      ctx[5], dirty &
      /*images*/
      1 && {
        alt:
        /*image*/
        ctx[5].alt || ""
      }]));
      internal.toggle_class(img, "svelte-lk00e3", true);
    },

    d(detaching) {
      if (detaching) internal.detach(div);
      dispose();
    }

  };
}

function create_fragment$1(ctx) {
  let div;
  let each_value =
  /*images*/
  ctx[0];
  let each_blocks = [];

  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }

  return {
    c() {
      div = internal.element("div");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      internal.attr(div, "class", "gallery svelte-lk00e3");
      internal.set_style(div, "--gutter",
      /*gutter*/
      ctx[1]);
    },

    m(target, anchor) {
      internal.insert(target, div, anchor);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
    },

    p(ctx, [dirty]) {
      if (dirty &
      /*images, popModal*/
      5) {
        each_value =
        /*images*/
        ctx[0];
        let i;

        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx, each_value, i);

          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }

        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }

        each_blocks.length = each_value.length;
      }

      if (dirty &
      /*gutter*/
      2) {
        internal.set_style(div, "--gutter",
        /*gutter*/
        ctx[1]);
      }
    },

    i: internal.noop,
    o: internal.noop,

    d(detaching) {
      if (detaching) internal.detach(div);
      internal.destroy_each(each_blocks, detaching);
    }

  };
}

function instance$1($$self, $$props, $$invalidate) {
  let {
    images = []
  } = $$props;
  let {
    gutter = 2
  } = $$props;
  const {
    open
  } = svelte.getContext("simple-modal");

  const popModal = idx => {
    open(Carousel, {
      images,
      curr_idx: idx
    });
  };

  const click_handler = i => popModal(i);

  $$self.$set = $$props => {
    if ("images" in $$props) $$invalidate(0, images = $$props.images);
    if ("gutter" in $$props) $$invalidate(1, gutter = $$props.gutter);
  };

  return [images, gutter, popModal, open, click_handler];
}

class Images extends internal.SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-lk00e3-style")) add_css$1();
    internal.init(this, options, instance$1, create_fragment$1, internal.safe_not_equal, {
      images: 0,
      gutter: 1
    });
  }

}

/* src/Images/Modal.svelte generated by Svelte v3.18.1 */

function add_css$2() {
  var style = internal.element("style");
  style.id = "svelte-p7calc-style";
  style.textContent = ".svelte-p7calc{box-sizing:border-box}.bg.svelte-p7calc{position:fixed;z-index:1000;display:flex;flex-direction:column;justify-content:center;width:100vw;height:100vh;background:rgba(0, 0, 0, 0.66)}.window-wrap.svelte-p7calc{position:relative}.window.svelte-p7calc{position:relative}.content.svelte-p7calc{position:relative}";
  internal.append(document.head, style);
} // (98:2) {#if Component}


function create_if_block$1(ctx) {
  let div3;
  let div2;
  let div1;
  let div0;
  let div1_transition;
  let div3_transition;
  let current;
  let dispose;
  const component_spread_levels = [
  /*props*/
  ctx[5]];
  let component_props = {};

  for (let i = 0; i < component_spread_levels.length; i += 1) {
    component_props = internal.assign(component_props, component_spread_levels[i]);
  }

  const component = new
  /*Component*/
  ctx[4]({
    props: component_props
  });
  return {
    c() {
      div3 = internal.element("div");
      div2 = internal.element("div");
      div1 = internal.element("div");
      div0 = internal.element("div");
      internal.create_component(component.$$.fragment);
      internal.attr(div0, "class", "content svelte-p7calc");
      internal.attr(div0, "style",
      /*cssContent*/
      ctx[10]);
      internal.attr(div1, "class", "window svelte-p7calc");
      internal.attr(div1, "style",
      /*cssWindow*/
      ctx[9]);
      internal.attr(div2, "class", "window-wrap svelte-p7calc");
      internal.attr(div3, "class", "bg svelte-p7calc");
      internal.attr(div3, "style",
      /*cssBg*/
      ctx[8]);
    },

    m(target, anchor) {
      internal.insert(target, div3, anchor);
      internal.append(div3, div2);
      internal.append(div2, div1);
      internal.append(div1, div0);
      internal.mount_component(component, div0, null);
      /*div2_binding*/

      ctx[29](div2);
      /*div3_binding*/

      ctx[30](div3);
      current = true;
      dispose = internal.listen(div3, "click",
      /*handleOuterClick*/
      ctx[12]);
    },

    p(ctx, dirty) {
      const component_changes = dirty &
      /*props*/
      32 ? internal.get_spread_update(component_spread_levels, [internal.get_spread_object(
      /*props*/
      ctx[5])]) : {};
      component.$set(component_changes);

      if (!current || dirty &
      /*cssContent*/
      1024) {
        internal.attr(div0, "style",
        /*cssContent*/
        ctx[10]);
      }

      if (!current || dirty &
      /*cssWindow*/
      512) {
        internal.attr(div1, "style",
        /*cssWindow*/
        ctx[9]);
      }

      if (!current || dirty &
      /*cssBg*/
      256) {
        internal.attr(div3, "style",
        /*cssBg*/
        ctx[8]);
      }
    },

    i(local) {
      if (current) return;
      internal.transition_in(component.$$.fragment, local);
      internal.add_render_callback(() => {
        if (!div1_transition) div1_transition = internal.create_bidirectional_transition(div1,
        /*transitionWindow*/
        ctx[2],
        /*transitionWindowProps*/
        ctx[3], true);
        div1_transition.run(1);
      });
      internal.add_render_callback(() => {
        if (!div3_transition) div3_transition = internal.create_bidirectional_transition(div3,
        /*transitionBg*/
        ctx[0],
        /*transitionBgProps*/
        ctx[1], true);
        div3_transition.run(1);
      });
      current = true;
    },

    o(local) {
      internal.transition_out(component.$$.fragment, local);
      if (!div1_transition) div1_transition = internal.create_bidirectional_transition(div1,
      /*transitionWindow*/
      ctx[2],
      /*transitionWindowProps*/
      ctx[3], false);
      div1_transition.run(0);
      if (!div3_transition) div3_transition = internal.create_bidirectional_transition(div3,
      /*transitionBg*/
      ctx[0],
      /*transitionBgProps*/
      ctx[1], false);
      div3_transition.run(0);
      current = false;
    },

    d(detaching) {
      if (detaching) internal.detach(div3);
      internal.destroy_component(component);
      if (detaching && div1_transition) div1_transition.end();
      /*div2_binding*/

      ctx[29](null);
      /*div3_binding*/

      ctx[30](null);
      if (detaching && div3_transition) div3_transition.end();
      dispose();
    }

  };
}

function create_fragment$2(ctx) {
  let div;
  let t;
  let current;
  let dispose;
  let if_block =
  /*Component*/
  ctx[4] && create_if_block$1(ctx);
  const default_slot_template =
  /*$$slots*/
  ctx[28].default;
  const default_slot = internal.create_slot(default_slot_template, ctx,
  /*$$scope*/
  ctx[27], null);
  return {
    c() {
      div = internal.element("div");
      if (if_block) if_block.c();
      t = internal.space();
      if (default_slot) default_slot.c();
      internal.attr(div, "class", "svelte-p7calc");
    },

    m(target, anchor) {
      internal.insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      internal.append(div, t);

      if (default_slot) {
        default_slot.m(div, null);
      }

      current = true;
      dispose = internal.listen(window, "keyup",
      /*handleKeyup*/
      ctx[11]);
    },

    p(ctx, [dirty]) {
      if (
      /*Component*/
      ctx[4]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          internal.transition_in(if_block, 1);
        } else {
          if_block = create_if_block$1(ctx);
          if_block.c();
          internal.transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        internal.group_outros();
        internal.transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        internal.check_outros();
      }

      if (default_slot && default_slot.p && dirty &
      /*$$scope*/
      134217728) {
        default_slot.p(internal.get_slot_context(default_slot_template, ctx,
        /*$$scope*/
        ctx[27], null), internal.get_slot_changes(default_slot_template,
        /*$$scope*/
        ctx[27], dirty, null));
      }
    },

    i(local) {
      if (current) return;
      internal.transition_in(if_block);
      internal.transition_in(default_slot, local);
      current = true;
    },

    o(local) {
      internal.transition_out(if_block);
      internal.transition_out(default_slot, local);
      current = false;
    },

    d(detaching) {
      if (detaching) internal.detach(div);
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
      dispose();
    }

  };
}

function instance$2($$self, $$props, $$invalidate) {
  let {
    key = "simple-modal"
  } = $$props;
  let {
    closeOnEsc = true
  } = $$props;
  let {
    closeOnOuterClick = true
  } = $$props;
  let {
    transitionBg = transition.fade
  } = $$props;
  let {
    transitionBgProps = {
      duration: 250
    }
  } = $$props;
  let {
    transitionWindow = transitionBg
  } = $$props;
  let {
    transitionWindowProps = transitionBgProps
  } = $$props;
  let {
    styleBg = {
      top: 0,
      left: 0
    }
  } = $$props;
  let {
    styleWindow = {}
  } = $$props;
  let {
    styleContent = {}
  } = $$props;
  let {
    setContext = svelte.setContext
  } = $$props;
  let Component = null;
  let props = null;
  let background;
  let wrap;
  let customStyleBg = {};
  let customStyleWindow = {};
  let customStyleContent = {};

  const camelCaseToDash = str => str.replace(/([a-zA-Z])(?=[A-Z])/g, "$1-").toLowerCase();

  const toCssString = props => Object.keys(props).reduce((str, key) => `${str}; ${camelCaseToDash(key)}: ${props[key]}`, "");

  const open = (NewComponent, newProps = {}, style = {
    bg: {},
    window: {},
    content: {}
  }) => {
    $$invalidate(4, Component = NewComponent);
    $$invalidate(5, props = newProps);
    $$invalidate(20, customStyleBg = style.bg || {});
    $$invalidate(21, customStyleWindow = style.window || {});
    $$invalidate(22, customStyleContent = style.content || {});
  };

  const close = () => {
    $$invalidate(4, Component = null);
    $$invalidate(5, props = null);
    $$invalidate(20, customStyleBg = {});
    $$invalidate(21, customStyleWindow = {});
    $$invalidate(22, customStyleContent = {});
  };

  const handleKeyup = ({
    key
  }) => {
    if (closeOnEsc && Component && key === "Escape") {
      event.preventDefault();
      close();
    }
  };

  const handleOuterClick = event => {
    if (closeOnOuterClick && (event.target === background || event.target === wrap)) {
      event.preventDefault();
      close();
    }
  };

  setContext(key, {
    open,
    close
  });
  let {
    $$slots = {},
    $$scope
  } = $$props;

  function div2_binding($$value) {
    internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      $$invalidate(7, wrap = $$value);
    });
  }

  function div3_binding($$value) {
    internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      $$invalidate(6, background = $$value);
    });
  }

  $$self.$set = $$props => {
    if ("key" in $$props) $$invalidate(13, key = $$props.key);
    if ("closeOnEsc" in $$props) $$invalidate(14, closeOnEsc = $$props.closeOnEsc);
    if ("closeOnOuterClick" in $$props) $$invalidate(15, closeOnOuterClick = $$props.closeOnOuterClick);
    if ("transitionBg" in $$props) $$invalidate(0, transitionBg = $$props.transitionBg);
    if ("transitionBgProps" in $$props) $$invalidate(1, transitionBgProps = $$props.transitionBgProps);
    if ("transitionWindow" in $$props) $$invalidate(2, transitionWindow = $$props.transitionWindow);
    if ("transitionWindowProps" in $$props) $$invalidate(3, transitionWindowProps = $$props.transitionWindowProps);
    if ("styleBg" in $$props) $$invalidate(16, styleBg = $$props.styleBg);
    if ("styleWindow" in $$props) $$invalidate(17, styleWindow = $$props.styleWindow);
    if ("styleContent" in $$props) $$invalidate(18, styleContent = $$props.styleContent);
    if ("setContext" in $$props) $$invalidate(19, setContext = $$props.setContext);
    if ("$$scope" in $$props) $$invalidate(27, $$scope = $$props.$$scope);
  };

  let cssBg;
  let cssWindow;
  let cssContent;

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*styleBg, customStyleBg*/
    1114112) {
       $$invalidate(8, cssBg = toCssString(Object.assign({}, styleBg, customStyleBg)));
    }

    if ($$self.$$.dirty &
    /*styleWindow, customStyleWindow*/
    2228224) {
       $$invalidate(9, cssWindow = toCssString(Object.assign({}, styleWindow, customStyleWindow)));
    }

    if ($$self.$$.dirty &
    /*styleContent, customStyleContent*/
    4456448) {
       $$invalidate(10, cssContent = toCssString(Object.assign({}, styleContent, customStyleContent)));
    }
  };

  return [transitionBg, transitionBgProps, transitionWindow, transitionWindowProps, Component, props, background, wrap, cssBg, cssWindow, cssContent, handleKeyup, handleOuterClick, key, closeOnEsc, closeOnOuterClick, styleBg, styleWindow, styleContent, setContext, customStyleBg, customStyleWindow, customStyleContent, camelCaseToDash, toCssString, open, close, $$scope, $$slots, div2_binding, div3_binding];
}

class Modal extends internal.SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-p7calc-style")) add_css$2();
    internal.init(this, options, instance$2, create_fragment$2, internal.safe_not_equal, {
      key: 13,
      closeOnEsc: 14,
      closeOnOuterClick: 15,
      transitionBg: 0,
      transitionBgProps: 1,
      transitionWindow: 2,
      transitionWindowProps: 3,
      styleBg: 16,
      styleWindow: 17,
      styleContent: 18,
      setContext: 19
    });
  }

}

/* src/Images/index.svelte generated by Svelte v3.18.1 */

function add_css$3() {
  var style = internal.element("style");
  style.id = "svelte-ot3ccz-style";
  style.textContent = ".svelte-images-container.svelte-ot3ccz{width:100%;height:100%;display:flex}.svelte-images-container > div{display:flex;flex:1 1}";
  internal.append(document.head, style);
} // (19:2) <Modal>


function create_default_slot(ctx) {
  let current;
  const images_spread_levels = [
  /*$$props*/
  ctx[0]];
  let images_props = {};

  for (let i = 0; i < images_spread_levels.length; i += 1) {
    images_props = internal.assign(images_props, images_spread_levels[i]);
  }

  const images = new Images({
    props: images_props
  });
  return {
    c() {
      internal.create_component(images.$$.fragment);
    },

    m(target, anchor) {
      internal.mount_component(images, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const images_changes = dirty &
      /*$$props*/
      1 ? internal.get_spread_update(images_spread_levels, [internal.get_spread_object(
      /*$$props*/
      ctx[0])]) : {};
      images.$set(images_changes);
    },

    i(local) {
      if (current) return;
      internal.transition_in(images.$$.fragment, local);
      current = true;
    },

    o(local) {
      internal.transition_out(images.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      internal.destroy_component(images, detaching);
    }

  };
}

function create_fragment$3(ctx) {
  let div;
  let current;
  const modal = new Modal({
    props: {
      $$slots: {
        default: [create_default_slot]
      },
      $$scope: {
        ctx
      }
    }
  });
  return {
    c() {
      div = internal.element("div");
      internal.create_component(modal.$$.fragment);
      internal.attr(div, "class", "svelte-images-container svelte-ot3ccz");
    },

    m(target, anchor) {
      internal.insert(target, div, anchor);
      internal.mount_component(modal, div, null);
      current = true;
    },

    p(ctx, [dirty]) {
      const modal_changes = {};

      if (dirty &
      /*$$scope*/
      2) {
        modal_changes.$$scope = {
          dirty,
          ctx
        };
      }

      modal.$set(modal_changes);
    },

    i(local) {
      if (current) return;
      internal.transition_in(modal.$$.fragment, local);
      current = true;
    },

    o(local) {
      internal.transition_out(modal.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      if (detaching) internal.detach(div);
      internal.destroy_component(modal);
    }

  };
}

function instance$3($$self, $$props, $$invalidate) {
  $$self.$set = $$new_props => {
    $$invalidate(0, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
  };

  $$props = internal.exclude_internal_props($$props);
  return [$$props];
}

class Images_1 extends internal.SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-ot3ccz-style")) add_css$3();
    internal.init(this, options, instance$3, create_fragment$3, internal.safe_not_equal, {});
  }

}

var index = (() => {
  return Images_1;
})();

module.exports = index;
//# sourceMappingURL=svelte-images.cjs.js.map
